# GEMINI.md - Instructions and Lessons Learned

This document provides instructions for setting up and running the "nina" application, as well as some lessons learned during its development.



## Lessons Learned

*   **Tooling Precision:** The `replace` tool requires surgical precision. Attempting to replace large, complex blocks of code is brittle and prone to failure. It is far more robust to perform a series of smaller, more targeted replacements. Always verify the `old_string` is an exact, unique match before executing.
*   **Verify, Then Code:** Do not assume knowledge of a third-party package's API. After a dependency is added, take a moment to verify the correct constructors and methods in the documentation. This prevents introducing bugs that are difficult to diagnose, as seen with the `StaggeredGridTile.count` constructor.
*   **`firebase_options.dart` is the Source of Truth:** When debugging backend issues (like Storage, Firestore, or Auth), always check `lib/firebase_options.dart` first. This file, generated by `flutterfire configure`, dictates exactly which Firebase project and resources (e.g., `projectId`, `storageBucket`) the client app is communicating with. Mismatches between this file and the resources being checked manually in the console are a common source of errors.
*   **Incomplete Refactoring:** A common source of error is incomplete refactoring. When changing a widget's state variable (e.g., from a `bool` to an `enum`), you must update the variable declaration, the constructor, and all call sites simultaneously. A partial change will leave the code in a non-compilable state.
*   **Use `flutter build` for Verification:** Instead of relying solely on the user to run the app in debug mode, use `flutter build web` (or other platform targets) as a definitive way to check for compilation errors after making code changes. It provides a faster and more reliable feedback loop.
*   **`NetworkImageLoadException` with Google User Content URLs:** Google User Content URLs can be rate-limited, which can cause `NetworkImageLoadException` with status code 429. It's important to handle this error gracefully, for example by providing a fallback UI.
*   **Flutter web build issues:** Sometimes the Flutter web build can get into a bad state, causing errors like "Bad state: Could not find summary for library". Running `flutter clean` and `flutter pub get`, or recreating the web-specific files with `flutter create . --platforms web` can help resolve these issues.
*   **`firebase_ai` package:** The `firebase_ai` package is still in development and the API is subject to change. When working with image generation, the `ImagenImage` class has a `bytesBase64Encoded` getter which returns a `String`, not a `Uint8List`. You need to use `base64Decode` to convert it to a `Uint8List` before displaying it.
*   **Code Organization:** As UI complexity grows, it's crucial to refactor large widget build methods into smaller, dedicated widget files (e.g., in a `lib/widgets/` directory). This improves maintainability and makes debugging and modification significantly easier.
*   **StaggeredGridTile API:** When using packages like `flutter_staggered_grid_view`, ensure you understand the correct constructor usage. `StaggeredGridTile.count` requires named parameters (`crossAxisCellCount`, `mainAxisCellCount`). For dynamic layouts, it's better to have helper functions return simple data objects (like a custom class holding dimensions) rather than returning configured widget instances.
*   **Client-Side Authorization Checks:** Attempting to check an allowlist in Firestore immediately after login from the client can fail due to permission errors. The user's authentication state (`request.auth`) may not be immediately available to Firestore's security rules in that context. The robust, secure solution is to delegate the authorization check to a trusted backend (like a Cloud Function or dedicated service) that can verify the user's token and query the allowlist with server-side privileges.


## Running and building

You can collaborate with the user by having them run the application in development mode where they can hot reload "R" 

You can also ask the user to provide Chrome developer console snippets.




